package org.jetbrains.research.testspark.tools.llm.generation

import com.intellij.openapi.components.service
import com.intellij.openapi.diagnostic.Logger
import com.intellij.openapi.progress.ProgressIndicator
import com.intellij.openapi.project.Project
import org.jetbrains.research.testspark.TestSparkBundle
import org.jetbrains.research.testspark.data.Report
import org.jetbrains.research.testspark.editor.Workspace
import org.jetbrains.research.testspark.services.TestCoverageCollectorService
import org.jetbrains.research.testspark.tools.llm.error.LLMErrorManager
import org.jetbrains.research.testspark.tools.llm.test.TestCaseGeneratedByLLM
import java.io.File

/**
 * The TestCoverageCollector class is responsible for collecting test coverage data and generating a report.
 *
 * @property indicator The progress indicator to display the current task progress.
 * @property project The project associated with the test generation.
 * @property generatedTestPaths The paths of the generated test files.
 * @property generatedTestFile The generated test file.
 * @property generatedTestPackage The package of the generated test file.
 * @property projectBuildPath The path to the project build directory.
 * @property testCases The list of test cases generated by the LLM.
 * @property fileNameFQN The fully qualified name of the file containing the class under test.
 */
class TestCoverageCollector(
    private val indicator: ProgressIndicator,
    private val project: Project,
    private val generatedTestPaths: List<String>,
    private val generatedTestFile: File,
    private val generatedTestPackage: String,
    private val projectBuildPath: String,
    private val testCases: MutableList<TestCaseGeneratedByLLM>,
) {
    private val log = Logger.getInstance(this::class.java)

    private val report = Report()

    /**
     * Executes Jacoco on the compiled test file and collects the Jacoco results.
     *
     * @return The normalized Jacoco report.
     */
    fun collect(): Report {
        log.info("Test collection begins")

        // run Jacoco on the compiled test file
        runJacoco()

        // collect the Jacoco results and return the report
        return report.normalized()
    }

    /**
     * Compiles the generated test file using the proper javac and returns a Pair
     * indicating whether the compilation was successful and any error message encountered during compilation.
     *
     * @return A Pair containing a boolean indicating whether the compilation was successful
     *         and a String containing any error message encountered during compilation.
     */
    fun compileTestCases(): Boolean {
        var result = false
        for (index in generatedTestPaths.indices) {
            val compilable = project.service<TestCoverageCollectorService>().compileCode(generatedTestPaths[index], projectBuildPath).first
            result = result || compilable
            if (compilable) {
                project.service<Workspace>().testGenerationData.compilableTestCases.add(testCases[index])
            }
        }
        return result
    }

    /**
     * Runs Jacoco to collect code coverage data and generate reports.
     */
    private fun runJacoco() {
        indicator.text = TestSparkBundle.message("runningJacoco")

        log.info("Running jacoco")

        // Execute each test method separately
        for (index in generatedTestPaths.indices) {
            val testCase = testCases[index]

            // name of .exec and .xml files
            val dataFileName = "${project.service<Workspace>().resultPath!!}/jacoco-${testCase.name}"

            val testExecutionError = project.service<TestCoverageCollectorService>().createXmlFromJacoco(
                generatedTestPaths[index].split('/').last().split('.')[0],
                dataFileName,
                testCase.name,
                projectBuildPath,
                generatedTestPackage,
            )

            // check if XML report is produced
            if (!File("$dataFileName.xml").exists()) {
                LLMErrorManager().errorProcess("Something went wrong with generating Jacoco report.", project)
                return
            }
            log.info("xml file exists")

            // save data to TestGenerationResult
            indicator.text = TestSparkBundle.message("testCasesSaving")
            report.testCaseList[testCase.name] = project.service<TestCoverageCollectorService>().getTestCaseFromXml(
                testCase.name,
                testCase.toString(),
                project.service<TestCoverageCollectorService>().getExceptionData(testExecutionError).second,
                "$dataFileName.xml",
            )
        }
        project.service<Workspace>().cleanFolder(project.service<Workspace>().resultPath!!)
    }
}
